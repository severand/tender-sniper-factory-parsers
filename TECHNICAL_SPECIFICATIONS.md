# üõ†Ô∏è Factory Parsers - –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤

## –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ

1. [–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –¥–µ–≤—é–ø–µ—Ä](#%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D0%B4%D0%B5%D0%B2%D0%B5%D0%BB%D0%BE%D0%BF%D0%B5%D1%80%D1%83)
2. [–ö–æ–¥–æ–≤—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã](#%D0%BA%D043e%D0%B4%D043e%D0%B2%D044b%D0%B5-%D1%81%D1%82%D0%B0%D043d%D0%B4%D0%B0%D1%80%D1%82%D044b)
3. [–û—Å–Ω–æ–≤–Ω—ã–µ —á—Ç–µ–Ω–∏–µ –∏ –æ–±—ã—á–∞–π](#%D043e%D0%B1%D044b%D0%B7%D0%B0%D1%82%D0%B5%D043b%D043d%D044b%D0%B5-%D043f%D0%B0%D1%82%D1%82%D0%B5%D1%80%D043d%D044b)
4. [–î–∞—Ç–∞–±–∞–∑—ã](#%D0%B4%D0%B0%D1%82%D0%B0%D0%B1%D0%B0%D0%B7%D044b)
5. [–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã](#%D0%B0%D1%81%D0%B8%D043d%D1%85%D1%80%D043e%D043d%D043d%D044b%D0%B5-%D0%BF%D1%80%D043e%D1%86%D0%B5%D1%81%D1%81%D044b)
6. [–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥](#%D043b%D043e%D0%B3%D0%B8%D1%80%D043e%D0%B2%D0%B0%D043d%D0%B8%D0%B5-%D0%B8-%D043c%D043e%D043d%D0%B8%D1%82%D043e%D1%80%D0%B8%D043d%D0%B3)
7. [–ù–∞–∂—É—Ç—ã –∏ –≥–æ—Ç—ç–∫–≤](#%D0%BF%D0%BE%D0%BF%D044b%D1%82%D043a%D0%B8-%D0%B8-%D0%BD%D043e%D0%B3%D043e%D1%82%D043e%D0%B2%D043a%D0%B8)
8. [–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ](#%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D043e%D0%B2%D0%B0%D043d%D0%B8%D0%B5)
9. [–î–µ–ø–ª–æ–π–º–µ–Ω—Ç](#%D0%B4%D0%B5%D043f%D043b%D043e%D0%B9%D043c%D0%B5%D043d%D1%82)
10. [–ü—Ä–∏–º–µ—Ä—ã](#%D043f%D1%80%D0%B8%D043c%D0%B5%D1%80%D044b)

---

## –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –¥–µ–≤–µ–ª–æ–ø–µ—Ä—É

### –ó–Ω–∞–Ω–∏—è

- ‚úÖ **Python 3.11+** (type hints, dataclasses, walrus operator)
- ‚úÖ **SQLAlchemy 2.0+** (ORM, async support)
- ‚úÖ **FastAPI** (async web framework)
- ‚úÖ **Scrapy** (web scraping framework)
- ‚úÖ **Playwright** (browser automation)
- ‚úÖ **Celery** (task queue)
- ‚úÖ **PostgreSQL** (SQL database)
- ‚úÖ **Redis** (cache & message broker)
- ‚úÖ **Elasticsearch/OpenSearch** (full-text search)
- ‚úÖ **pytest** (testing framework)

### –ù–∞—Ä—É–∂–Ω—ã–µ –Ω–∞—Ä–º–∞–º–∏

```bash
Python:        3.11+
pip:           latest
poetry:        optional (prefer pip + requirements.txt)
Docker:        latest
Git:           2.30+
```

### –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–æ–æ–ª—ã

```bash
pylint              # Linting
black               # Code formatter
isort               # Import sorter
pytest              # Testing
pytest-cov          # Coverage
mypy                # Type checker
pydantic            # Data validation
structlog           # Structured logging
alembic             # Database migrations
```

---

## –ö–æ–¥–æ–≤—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã

### 1. Type Hints (MANDATORY)

–ü—Ä–∏–º–µ—Ä:

```python
from typing import Optional, List, Dict, Tuple
from pydantic import BaseModel

class TenderFilters(BaseModel):
    """Tender filter criteria."""
    min_budget: Optional[float] = None
    max_budget: Optional[float] = None
    platforms: List[str] = []
    region: Optional[str] = None

async def fetch_tenders(
    filters: TenderFilters,
    page: int = 1,
    limit: int = 50
) -> Tuple[List[Dict], int]:
    """Fetch tenders matching filters.
    
    Args:
        filters: Filter criteria
        page: Page number (1-indexed)
        limit: Items per page
        
    Returns:
        Tuple of (tender_list, total_count)
    """
    # Implementation
    pass
```

### 2. Docstrings (Google format)

```python
def process_tender(
    raw_data: Dict[str, Any],
    platform_id: str
) -> Tender:
    """Process raw tender data into normalized format.
    
    Validates input, applies field mapping, and saves to database.
    
    Args:
        raw_data: Raw tender dict from API/scraper
        platform_id: Source platform identifier
        
    Returns:
        Normalized Tender model
        
    Raises:
        ValueError: If data fails validation
        DatabaseError: If save fails
        
    Examples:
        >>> tender = process_tender({...}, "e-tender-kz")
        >>> print(tender.id)
    """
    pass
```

### 3. Naming Conventions

```python
# Classes: PascalCase
class TenderNormalizer:
    pass

class APIClientFactory:
    pass

# Functions: snake_case
async def fetch_tender_list():
    pass

def calculate_budget():
    pass

# Constants: UPPER_SNAKE_CASE
MAX_RETRIES = 3
DEFAULT_TIMEOUT = 30
CACHE_TTL_SECONDS = 3600

# Private: _leading_underscore
def _validate_url(url: str) -> bool:
    pass

class _InternalHelper:
    pass
```

### 4. Line Length & Formatting

```bash
# Use black for formatting
black factory_parsers/

# Max line length: 100 chars (black default)
# Use multiline for long expressions
result = (
    query
    .filter(Tender.budget > min_budget)
    .filter(Tender.platform_id == platform_id)
    .limit(page_size)
    .offset((page - 1) * page_size)
)
```

### 5. Import Organization

```python
# Use isort to auto-format
# isort factory_parsers/

# Standard library
import asyncio
import json
from typing import List, Dict
from pathlib import Path

# Third-party
import sqlalchemy as sa
from pydantic import BaseModel, Field
from fastapi import FastAPI, HTTPException

# Local
from factory_parsers.shared.logger import get_logger
from factory_parsers.storage_layer.models import Tender
from factory_parsers.admin_service.repository import PlatformRepo
```

### 6. Error Handling

```python
# Use custom exceptions
from factory_parsers.shared.exceptions import (
    PlatformNotFound,
    ParseError,
    RateLimitExceeded,
)

try:
    platform = await platform_repo.get_by_id(platform_id)
except PlatformNotFound as e:
    logger.warning(f"Platform not found: {platform_id}")
    raise HTTPException(status_code=404, detail=str(e))
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    raise HTTPException(status_code=500, detail="Internal server error")
```

---

## –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã

### Repository Pattern

```python
from abc import ABC, abstractmethod
from typing import Optional, List

class BaseRepository(ABC):
    """Abstract repository for data access."""
    
    @abstractmethod
    async def get_by_id(self, id: str) -> Optional[Any]:
        pass
    
    @abstractmethod
    async def list(self, skip: int = 0, limit: int = 50) -> List[Any]:
        pass
    
    @abstractmethod
    async def create(self, data: Dict) -> Any:
        pass

class PlatformRepository(BaseRepository):
    """Platform data access layer."""
    
    def __init__(self, db_session: AsyncSession):
        self.db_session = db_session
    
    async def get_by_id(self, id: str) -> Optional[Platform]:
        return await self.db_session.get(Platform, id)
```

### Dependency Injection

```python
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

async def get_db_session() -> AsyncSession:
    """Provide database session."""
    async with async_session() as session:
        yield session

async def get_platform_repo(
    db_session: AsyncSession = Depends(get_db_session)
) -> PlatformRepository:
    """Provide platform repository."""
    return PlatformRepository(db_session)

@router.get("/platforms/{id}")
async def get_platform(
    id: str,
    repo: PlatformRepository = Depends(get_platform_repo)
):
    return await repo.get_by_id(id)
```

### Pydantic Models for Validation

```python
from pydantic import BaseModel, Field, validator

class PlatformCreate(BaseModel):
    """Schema for creating a platform."""
    name: str = Field(..., min_length=1, max_length=100)
    base_url: str = Field(..., regex=r'^https?://')
    mode: str = Field(default="auto", regex=r'^(auto|api_only|web_only)$')
    rate_limit_rps: int = Field(default=5, ge=1, le=100)
    
    @validator('base_url')
    def validate_url(cls, v):
        if not v.startswith(('http://', 'https://')):
            raise ValueError('Must be a valid HTTP URL')
        return v
    
    class Config:
        json_schema_extra = {
            "example": {
                "name": "e-tender.kz",
                "base_url": "https://www.etender.kz",
                "mode": "auto"
            }
        }
```

---

## –î–∞—Ç–∞–±–∞–∑—ã

### PostgreSQL Setup

```bash
# –í docker-compose.yml
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: factory_parsers
      POSTGRES_USER: parser
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
```

### Alembic Migrations

```bash
# Initialize migration
alembic revision --autogenerate -m "Add Platform table"

# Apply migrations
alembic upgrade head

# Rollback
alembic downgrade -1
```

### Connection String

```python
# .env
DATABASE_URL=postgresql+asyncpg://parser:password@localhost:5432/factory_parsers

# config.py
from sqlalchemy.ext.asyncio import create_async_engine

engine = create_async_engine(
    os.getenv("DATABASE_URL"),
    echo=False,
    pool_size=20,
    max_overflow=0,
    pool_pre_ping=True,  # Verify connections before use
)
```

---

## –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã

### Celery Configuration

```python
# factory_parsers/shared/celery_app.py
from celery import Celery

app = Celery(
    'factory_parsers',
    broker=os.getenv('CELERY_BROKER_URL', 'redis://localhost:6379/0'),
    backend=os.getenv('CELERY_RESULT_BACKEND', 'redis://localhost:6379/1'),
)

app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,
    task_track_started=True,
    task_time_limit=30 * 60,  # 30 minutes
    task_soft_time_limit=25 * 60,  # 25 minutes
)
```

### Task Definition

```python
from factory_parsers.shared.celery_app import app
from factory_parsers.shared.logger import get_logger

logger = get_logger(__name__)

@app.task(
    bind=True,
    max_retries=3,
    default_retry_delay=60,
    acks_late=True,
)
def process_tender_task(self, raw_tender_id: str):
    """Process raw tender.
    
    Args:
        raw_tender_id: ID of raw tender to process
    """
    try:
        logger.info(f"Processing tender: {raw_tender_id}")
        # Implementation
    except Exception as exc:
        logger.error(f"Error processing tender: {exc}")
        raise self.retry(exc=exc)
```

### Periodic Tasks

```python
from celery.schedules import crontab

app.conf.beat_schedule = {
    'schedule-tenders-every-hour': {
        'task': 'factory_parsers.scheduler_service.tasks.schedule_tenders',
        'schedule': crontab(minute=0),  # Every hour
    },
    'cleanup-cache-every-day': {
        'task': 'factory_parsers.cache_layer.tasks.cleanup_cache',
        'schedule': crontab(hour=2, minute=0),  # Every day at 2 AM
    },
}
```

---

## –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥

### Structured Logging with structlog

```python
# factory_parsers/shared/logger.py
import structlog

logger = structlog.get_logger(__name__)

# Usage
logger.info(
    "tender_processed",
    tender_id="uuid",
    platform="e-tender",
    duration_ms=1234,
    status="success"
)

# Output
{
  "timestamp": "2025-12-16T12:00:00Z",
  "level": "info",
  "logger": "factory_parsers.web_scraper",
  "event": "tender_processed",
  "tender_id": "uuid",
  "platform": "e-tender",
  "duration_ms": 1234,
  "status": "success"
}
```

### Metrics with Prometheus

```python
from prometheus_client import Counter, Histogram

tenders_processed = Counter(
    'tenders_processed_total',
    'Total tenders processed',
    ['platform', 'status']
)

processing_time = Histogram(
    'tender_processing_seconds',
    'Time to process tender',
    ['service']
)

# Usage
tenders_processed.labels(platform='e-tender', status='success').inc()
with processing_time.labels(service='normalizer').time():
    # Do work
    pass
```

---

## –ù–∞–ø—É—Ç—ã –∏ –≥–æ—Ç—ç–∫–≤

### –ù—Ä–µ–Ω—Ç —Ä–µ—Ç—Ä–∞–π

```python
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
)

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10),
    retry=retry_if_exception_type((ConnectionError, TimeoutError)),
)
async def fetch_url(url: str) -> str:
    """Fetch URL with retry logic."""
    # Implementation
    pass
```

### Circuit Breaker

```python
from pybreaker import CircuitBreaker

api_breaker = CircuitBreaker(
    fail_max=5,
    reset_timeout=60,
    exclude=[ValueError],  # Don't break on validation errors
)

@api_breaker
async def call_external_api(url: str):
    """Call external API with circuit breaker."""
    pass
```

### Rate Limiting

```python
from ratelimit import limits, sleep_and_retry
import time

@sleep_and_retry
@limits(calls=5, period=60)  # 5 calls per 60 seconds
async def api_call(platform_id: str):
    """API call with rate limiting."""
    pass
```

---

## –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### pytest Structure

```
factory_parsers/
‚îú‚îÄ‚îÄ admin_service/
‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conftest.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_models.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_repository.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_routes.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_service.py
tests/
‚îú‚îÄ‚îÄ conftest.py
‚îú‚îÄ‚îÄ test_integration.py
‚îî‚îÄ‚îÄ test_e2e.py
```

### Test Examples

```python
# tests/conftest.py
import pytest
from sqlalchemy.ext.asyncio import create_async_engine

@pytest.fixture
async def db_session():
    """Provide test database session."""
    engine = create_async_engine('sqlite+aiosqlite:///:memory:')
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    async with AsyncSession(engine) as session:
        yield session

# tests/test_admin.py
@pytest.mark.asyncio
async def test_create_platform(db_session):
    """Test platform creation."""
    repo = PlatformRepository(db_session)
    
    # Create
    platform = await repo.create({
        'name': 'Test Platform',
        'base_url': 'https://test.com'
    })
    
    # Assert
    assert platform.id is not None
    assert platform.name == 'Test Platform'
    
    # Retrieve
    retrieved = await repo.get_by_id(platform.id)
    assert retrieved.name == 'Test Platform'
```

### Coverage

```bash
# Run tests with coverage
pytest --cov=factory_parsers --cov-report=html

# Minimum coverage: 80%
# Critical paths: 95%
```

---

## –î–µ–ø–ª–æ–π–º–µ–Ω—Ç

### Docker Compose

```yaml
# docker-compose.yml
version: '3.9'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: factory_parsers
      POSTGRES_USER: parser
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  scheduler:
    build:
      context: .
      dockerfile: docker/Dockerfile.scheduler
    environment:
      DATABASE_URL: ${DATABASE_URL}
      CELERY_BROKER_URL: redis://redis:6379/0
    depends_on:
      - postgres
      - redis

  worker:
    build:
      context: .
      dockerfile: docker/Dockerfile.worker
    environment:
      DATABASE_URL: ${DATABASE_URL}
      CELERY_BROKER_URL: redis://redis:6379/0
    depends_on:
      - postgres
      - redis
```

### Start Commands

```bash
# Development
docker-compose up

# Production
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# Local development
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
alembic upgrade head
python -m pytest
```

---

## –ü—Ä–∏–º–µ—Ä—ã

### –ü—Ä–∏–º–µ—Ä: Admin Service - Create Platform

```python
# factory_parsers/admin_service/routes.py
from fastapi import APIRouter, Depends, HTTPException
from factory_parsers.admin_service.models import PlatformCreate, Platform
from factory_parsers.admin_service.repository import PlatformRepository

router = APIRouter(prefix="/api/admin/platforms", tags=["admin"])

@router.post("/", response_model=Platform)
async def create_platform(
    platform_data: PlatformCreate,
    repo: PlatformRepository = Depends(get_platform_repo)
):
    """Create a new platform."""
    try:
        # Check if already exists
        existing = await repo.get_by_name(platform_data.name)
        if existing:
            raise HTTPException(status_code=409, detail="Platform already exists")
        
        # Create
        platform = await repo.create(platform_data.dict())
        return platform
    except Exception as e:
        logger.error(f"Error creating platform: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
```

### –ü—Ä–∏–º–µ—Ä: Celery Task - Process Tender

```python
# factory_parsers/normalizer_service/worker.py
from factory_parsers.shared.celery_app import app
from factory_parsers.normalizer_service.normalizer import TenderNormalizer
from factory_parsers.storage_layer.db_client import get_db_client

@app.task(
    bind=True,
    max_retries=3,
    default_retry_delay=60,
    acks_late=True,
)
def normalize_tender(self, raw_tender_id: str, ai_extraction_id: str):
    """Normalize raw tender with AI extraction."""
    try:
        db = get_db_client()
        normalizer = TenderNormalizer(db)
        
        # Process
        tender = await normalizer.normalize(
            raw_tender_id=raw_tender_id,
            ai_extraction_id=ai_extraction_id
        )
        
        # Log success
        logger.info(
            "tender_normalized",
            tender_id=tender.id,
            platform=tender.platform_id,
        )
        
        return {"tender_id": tender.id, "status": "success"}
        
    except Exception as exc:
        logger.error(f"Normalization failed: {exc}", exc_info=True)
        raise self.retry(exc=exc, countdown=60 * (2 ** self.request.retries))
```

---

## –û—Ç —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞

üí° **–ü—Ä–∏ —Ä–µ–∑–æ–ª—é—Ü–∏–∏ –≤–æ–ø—Ä–æ—Å–æ–≤**:
1. –ù–∞–π—Ç–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–µ –æ–Ω—Ç–∏ –≤ tests/
2. –ü—Ä–∏—Å–º–æ—Ç—Ä–µ—Ç—å—Å—è –∫ –¥—Ä—É–≥–∏–º –º–æ–¥—É–ª—è–º (shared/, storage_layer/)
3. –ö–æ–Ω—Å—É–ª—å—Ç–∏—Ä—É—è—Å—å —Å PM –≤ Slack

üíÄ **–ö–æ–¥–µ–∫—Å**:
- –ù–µ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–π –æ—Ç –∫–æ–¥ –±–µ–∑ —Ä–µ—Å–∏—Ä–≤–∞—Ü–∏–∏ PM
- –ù–µ —Ç—Ä–æ–Ω–∏ –æ—Å–Ω–æ–≤—ç–π —Ç—è–∫—Ç—É (Celery, Scrapy settings)
- –í—Å–µ–≥–¥–∞ –¥–µ–ª–∞–π –Ω–æ–≤—ã–µ –≤–∏—Ç–∫–∏: git checkout -b feature/
- –ü—É—à –≤ —Ñ–∏—á –≤–µ—Ç–∫–∏ –¥–ª—è PR –∏ –ö–æ–Ω–µ —Ä–∏–≤—å—é

---

**–†–µ–≤–∏–∑–∏—è**: 1.0.0  
**–û—Ç —Ä–∞—á—è–ª–∞**: 2025-12-16  
**–õ–∞—Å—Ç —É–ø–¥–µ–π—Ç**: 2025-12-16
